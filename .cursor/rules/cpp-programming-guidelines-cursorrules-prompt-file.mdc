---
description: C++ rules for embedded development using Mbed OS Community Edition (RTOS, ISR-safe, deterministic)
globs: **/*.c,**/*.cpp,**/*.h,**/*.hpp,**/*.cxx,CMakeLists.txt,*.cmake,conanfile.txt,Makefile,**/*.cc
alwaysApply: false
---
# C++ Development Rules

You are a senior C++ developer with expertise in modern C++ (C++20), STL, and system-level programming.

## C++ Language

- Target C++20 with embedded constraints
- Avoid RTTI and heavy runtime features
- Prefer determinism over abstraction

## Naming

- Classes and structs: PascalCase
- Functions and variables: camelCase
- Constants and macros: SCREAMING_SNAKE_CASE
- Member variables prefixed with `m_` or `_`

## File Organization

- Headers in .hpp, implementations in .cpp
- Organize by functional modules (imu, processing, session, usb, utils, tests)

## Mbed OS

- Assume Mbed OS Community Edition with RTOS enabled
- Use mbed::EventFlags, rtos::Queue, rtos::Thread
- Do not introduce POSIX or platform-specific APIs
- Avoid dynamic memory in time-critical paths

## ISR and Real-Time

- ISR code must be minimal and deterministic
- Do not allocate memory or block in ISR
- Do not log or perform I/O in ISR
- Use EventFlags or Queue to signal threads
- Never take mutexes or throw exceptions in ISR

## Memory Management

- Prefer static or stack allocation
- Preallocate buffers at startup
- Avoid new/delete in real-time threads
- std::vector allowed only with fixed capacity
- Prefer std::array and fixed-size ring buffers
- Use RAII for peripherals

## C++ Features

- Prefer auto, constexpr, range-based for
- Prefer std::array, std::optional (non-ISR), std::variant
- Prefer std::string_view for read-only strings
- Avoid std::shared_ptr
- Avoid implicit dynamic allocation

## Error Handling

- Use error codes in ISR and real-time threads
- Exceptions allowed only in non-real-time paths
- Validate inputs at module boundaries
- Use MBED_ASSERT and static_assert
- Logging must be non-blocking and outside ISR

## Concurrency

- Thread priority order: IMU ISR > Acquisition > Processing > Step Detection > Session > USB > LED
- Avoid mutexes in high-frequency threads
- Prefer message passing over shared state

## Performance

- Minimize floating-point work in ISR paths
- Precompute constants and coefficients
- Avoid unnecessary copies
- Keep execution time predictable

## Safety

- Prevent buffer overflows
- Validate sensor ranges
- Detect and recover from I2C lockups
- Feed watchdog from main control thread
- Fail gracefully on peripheral errors

## Testing

- Unit test step detection, filters, state machines, USB parsing
- Use mock sensor data
- Avoid hardware dependencies in unit tests

## Documentation

- Use Doxygen-style comments
- Document thread priorities, ISR latency, buffer sizes
- Explain non-obvious design decisions
